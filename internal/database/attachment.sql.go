// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: attachment.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countAttachments = `-- name: CountAttachments :one
SELECT COUNT(*) FROM attachments
`

func (q *Queries) CountAttachments(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAttachments)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAttachment = `-- name: CreateAttachment :one
INSERT INTO attachments (filename, filepath, filesize, filetype, user_id, attachable_type, attachable_id)
VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING id, filename, filepath, filesize, filetype, user_id, attachable_type, attachable_id, created_at, updated_at
`

type CreateAttachmentParams struct {
	Filename       string      `json:"filename"`
	Filepath       string      `json:"filepath"`
	Filesize       int64       `json:"filesize"`
	Filetype       string      `json:"filetype"`
	UserID         pgtype.Int8 `json:"user_id"`
	AttachableType string      `json:"attachable_type"`
	AttachableID   int64       `json:"attachable_id"`
}

func (q *Queries) CreateAttachment(ctx context.Context, arg CreateAttachmentParams) (Attachment, error) {
	row := q.db.QueryRow(ctx, createAttachment,
		arg.Filename,
		arg.Filepath,
		arg.Filesize,
		arg.Filetype,
		arg.UserID,
		arg.AttachableType,
		arg.AttachableID,
	)
	var i Attachment
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Filepath,
		&i.Filesize,
		&i.Filetype,
		&i.UserID,
		&i.AttachableType,
		&i.AttachableID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAttachment = `-- name: DeleteAttachment :exec
DELETE FROM attachments
WHERE id = $1
`

func (q *Queries) DeleteAttachment(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteAttachment, id)
	return err
}

const findAttachmentById = `-- name: FindAttachmentById :one
SELECT id, filename, filepath, filesize, filetype, user_id, attachable_type, attachable_id, created_at, updated_at FROM attachments WHERE id = $1
`

func (q *Queries) FindAttachmentById(ctx context.Context, id int64) (Attachment, error) {
	row := q.db.QueryRow(ctx, findAttachmentById, id)
	var i Attachment
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Filepath,
		&i.Filesize,
		&i.Filetype,
		&i.UserID,
		&i.AttachableType,
		&i.AttachableID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findAttachmentsByAttachable = `-- name: FindAttachmentsByAttachable :many
SELECT id, filename, filepath, filesize, filetype, user_id, attachable_type, attachable_id, created_at, updated_at FROM attachments WHERE attachable_type = $1 AND attachable_id = $2
`

type FindAttachmentsByAttachableParams struct {
	AttachableType string `json:"attachable_type"`
	AttachableID   int64  `json:"attachable_id"`
}

func (q *Queries) FindAttachmentsByAttachable(ctx context.Context, arg FindAttachmentsByAttachableParams) ([]Attachment, error) {
	rows, err := q.db.Query(ctx, findAttachmentsByAttachable, arg.AttachableType, arg.AttachableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Filepath,
			&i.Filesize,
			&i.Filetype,
			&i.UserID,
			&i.AttachableType,
			&i.AttachableID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findAttachmentsByUserId = `-- name: FindAttachmentsByUserId :many
SELECT id, filename, filepath, filesize, filetype, user_id, attachable_type, attachable_id, created_at, updated_at FROM attachments WHERE user_id = $1
`

func (q *Queries) FindAttachmentsByUserId(ctx context.Context, userID pgtype.Int8) ([]Attachment, error) {
	rows, err := q.db.Query(ctx, findAttachmentsByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Filepath,
			&i.Filesize,
			&i.Filetype,
			&i.UserID,
			&i.AttachableType,
			&i.AttachableID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findManyAttachments = `-- name: FindManyAttachments :many
SELECT id, filename, filepath, filesize, filetype, user_id, attachable_type, attachable_id, created_at, updated_at FROM attachments
`

func (q *Queries) FindManyAttachments(ctx context.Context) ([]Attachment, error) {
	rows, err := q.db.Query(ctx, findManyAttachments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Filepath,
			&i.Filesize,
			&i.Filetype,
			&i.UserID,
			&i.AttachableType,
			&i.AttachableID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findManyAttachmentsWithPagination = `-- name: FindManyAttachmentsWithPagination :many
SELECT id, filename, filepath, filesize, filetype, user_id, attachable_type, attachable_id, created_at, updated_at FROM attachments
WHERE id > 0
ORDER BY id
LIMIT $2 OFFSET $1
`

type FindManyAttachmentsWithPaginationParams struct {
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FindManyAttachmentsWithPagination(ctx context.Context, arg FindManyAttachmentsWithPaginationParams) ([]Attachment, error) {
	rows, err := q.db.Query(ctx, findManyAttachmentsWithPagination, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Attachment
	for rows.Next() {
		var i Attachment
		if err := rows.Scan(
			&i.ID,
			&i.Filename,
			&i.Filepath,
			&i.Filesize,
			&i.Filetype,
			&i.UserID,
			&i.AttachableType,
			&i.AttachableID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAttachment = `-- name: UpdateAttachment :one
UPDATE attachments
SET filename = $1, filepath = $2, filesize = $3, filetype = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $5
RETURNING id, filename, filepath, filesize, filetype, user_id, attachable_type, attachable_id, created_at, updated_at
`

type UpdateAttachmentParams struct {
	Filename string `json:"filename"`
	Filepath string `json:"filepath"`
	Filesize int64  `json:"filesize"`
	Filetype string `json:"filetype"`
	ID       int64  `json:"id"`
}

func (q *Queries) UpdateAttachment(ctx context.Context, arg UpdateAttachmentParams) (Attachment, error) {
	row := q.db.QueryRow(ctx, updateAttachment,
		arg.Filename,
		arg.Filepath,
		arg.Filesize,
		arg.Filetype,
		arg.ID,
	)
	var i Attachment
	err := row.Scan(
		&i.ID,
		&i.Filename,
		&i.Filepath,
		&i.Filesize,
		&i.Filetype,
		&i.UserID,
		&i.AttachableType,
		&i.AttachableID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
